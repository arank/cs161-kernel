kern/gdbscripts/array:62:Usage: threadarray curproc->p_threads
kern/proc/proc.c:371:	spinlock_acquire(&curproc->p_lock);
kern/proc/proc.c:373:	if (curproc->p_cwd != NULL) {
kern/proc/proc.c:374:		VOP_INCREF(curproc->p_cwd);
kern/proc/proc.c:375:		proc->p_cwd = curproc->p_cwd;
kern/proc/proc.c:377:	spinlock_release(&curproc->p_lock);
kern/syscall/fork.c:22:    struct proc *child = proc_create(curproc->p_name);
kern/syscall/fork.c:34:    int rv = as_copy(curproc->p_addrspace, &child_addrspace);
kern/syscall/fork.c:40:        if (curproc->fd_table[i] != NULL) {
kern/syscall/fork.c:41:            child->fd_table[i] = curproc->fd_table[i];
kern/syscall/fork.c:42:            curproc->fd_table[i]->ref_count++;
kern/syscall/fork.c:47:	if (curproc->p_cwd != NULL) {
kern/syscall/fork.c:48:		VOP_INCREF(curproc->p_cwd);
kern/syscall/fork.c:49:		child->p_cwd = curproc->p_cwd;
kern/syscall/fork.c:109:    curproc->children[index] = child->parent;
kern/syscall/fork.c:110:    curproc->children[index]->ref_count++;
kern/syscall/fs_calls.c:36:    	if(curproc->fd_table[i] == NULL) break;
kern/syscall/fs_calls.c:49:    curproc->fd_table[i]=fd;
kern/syscall/fs_calls.c:61:    if (fd < 0 || fd >= OPEN_MAX || !curproc->fd_table[fd]) return EBADF;
kern/syscall/fs_calls.c:63:	struct file_desc *fd_ptr = curproc->fd_table[fd];
kern/syscall/fs_calls.c:77:	io.uio_space = curproc->p_addrspace;
kern/syscall/fs_calls.c:100:    if (fd < 0 || fd >= OPEN_MAX || !curproc->fd_table[fd]) return EBADF;
kern/syscall/fs_calls.c:102:    lock_acquire(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:112:    uio.uio_offset = curproc->fd_table[fd]->offset;
kern/syscall/fs_calls.c:115:    uio.uio_space = curproc->p_addrspace;
kern/syscall/fs_calls.c:117:    int rv = VOP_WRITE(curproc->fd_table[fd]->vn, &uio);
kern/syscall/fs_calls.c:119:        lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:123:    *bwritten = uio.uio_offset - curproc->fd_table[fd]->offset;
kern/syscall/fs_calls.c:124:	curproc->fd_table[fd]->offset = uio.uio_offset;
kern/syscall/fs_calls.c:125:    lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:142:    if (fd < 0 || fd >= OPEN_MAX || !curproc->fd_table[fd]) return EBADF;
kern/syscall/fs_calls.c:144:    lock_acquire(curproc->fd_table[fd]->lock);  
kern/syscall/fs_calls.c:145:    if (--curproc->fd_table[fd]->ref_count != 0)    
kern/syscall/fs_calls.c:146:        lock_release(curproc->fd_table[fd]->lock);  
kern/syscall/fs_calls.c:148:        vfs_close(curproc->fd_table[fd]->vn);
kern/syscall/fs_calls.c:149:        lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:150:        lock_destroy(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:151:        kfree(curproc->fd_table[fd]);
kern/syscall/fs_calls.c:154:    curproc->fd_table[fd] = NULL;
kern/syscall/fs_calls.c:159:    if (fd < 0 || fd >= OPEN_MAX || !curproc->fd_table[fd]) return EBADF;
kern/syscall/fs_calls.c:164:    lock_acquire(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:167:    if (VOP_STAT(curproc->fd_table[fd]->vn, &stat)) {/* get the end of file */
kern/syscall/fs_calls.c:168:        lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:174:    else if (whence == SEEK_CUR) new_pos = curproc->fd_table[fd]->offset + pos;
kern/syscall/fs_calls.c:178:        lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:182:    if (VOP_TRYSEEK(curproc->fd_table[fd]->vn, new_pos)) {
kern/syscall/fs_calls.c:183:        lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:187:    curproc->fd_table[fd]->offset = new_pos;
kern/syscall/fs_calls.c:188:    *ret_pos = curproc->fd_table[fd]->offset;
kern/syscall/fs_calls.c:189:    lock_release(curproc->fd_table[fd]->lock);
kern/syscall/fs_calls.c:196:                || curproc->fd_table[oldfd] == NULL ) return EBADF;
kern/syscall/fs_calls.c:198:    if (oldfd == newfd || curproc->fd_table[oldfd] == curproc->fd_table[newfd]) {
kern/syscall/fs_calls.c:203:	if(curproc->fd_table[newfd] != NULL)
kern/syscall/fs_calls.c:206:    KASSERT(curproc->fd_table[newfd] == NULL);
kern/syscall/fs_calls.c:207:	curproc->fd_table[newfd] = curproc->fd_table[oldfd];
kern/syscall/fs_calls.c:209:	lock_acquire(curproc->fd_table[newfd]->lock);
kern/syscall/fs_calls.c:210:    curproc->fd_table[newfd]->ref_count++;
kern/syscall/fs_calls.c:211:	lock_release(curproc->fd_table[newfd]->lock);
kern/syscall/proc_calls.c:61:    	shared = curproc->children[i];
kern/syscall/proc_calls.c:95:	*pid = curproc->pid;
kern/syscall/sbrk.c:14:	struct addrspace *as= curproc->p_addrspace;
kern/vfs/vfscwd.c:53:	spinlock_acquire(&curproc->p_lock);
kern/vfs/vfscwd.c:54:	if (curproc->p_cwd!=NULL) {
kern/vfs/vfscwd.c:55:		VOP_INCREF(curproc->p_cwd);
kern/vfs/vfscwd.c:56:		*ret = curproc->p_cwd;
kern/vfs/vfscwd.c:61:	spinlock_release(&curproc->p_lock);
kern/vfs/vfscwd.c:87:	spinlock_acquire(&curproc->p_lock);
kern/vfs/vfscwd.c:88:	old = curproc->p_cwd;
kern/vfs/vfscwd.c:89:	curproc->p_cwd = dir;
kern/vfs/vfscwd.c:90:	spinlock_release(&curproc->p_lock);
kern/vfs/vfscwd.c:107:	spinlock_acquire(&curproc->p_lock);
kern/vfs/vfscwd.c:108:	old = curproc->p_cwd;
kern/vfs/vfscwd.c:109:	curproc->p_cwd = NULL;
kern/vfs/vfscwd.c:110:	spinlock_release(&curproc->p_lock);
kern/vm/backingstore.c:83:	if(curproc->pid == 0)
kern/vm/backingstore.c:86:		io.uio_space = curproc->p_addrspace;
kern/vm/backingstore.c:143:	if(curproc->pid == 0)
kern/vm/backingstore.c:146:		uio.uio_space = curproc->p_addrspace;
kern/vm/coremap.c:181:	coremap.cm[index].pid = (is_kern) ? 0 : curproc->pid;
kern/vm/coremap.c:499:    if (!is_valid_addr(faultaddress, curproc->p_addrspace)) return EFAULT;
kern/vm/coremap.c:501:	struct page_table *pt = curproc->p_addrspace->page_dir->dir[PDI(faultaddress)];
